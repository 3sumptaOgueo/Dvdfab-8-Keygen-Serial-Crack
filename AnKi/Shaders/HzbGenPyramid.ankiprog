// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// The 1st reduction is average depth. The next reductions are max depth

#pragma anki start comp
#include <AnKi/Shaders/Common.hlsl>

struct Uniforms
{
	U32 m_threadGroupCount;
	U32 m_mipmapCount;
	U32 m_padding0;
	U32 m_padding1;
};

[[vk::push_constant]] ConstantBuffer<Uniforms> g_uniforms;

[[vk::binding(0)]] globallycoherent RWTexture2D<UVec4> g_dstUavs[12u];
[[vk::binding(1)]] globallycoherent RWStructuredBuffer<U32> g_spdCounter;
[[vk::binding(2)]] Texture2D<UVec4> g_srcTex;

// Include SPD
#define A_GPU 1
#define A_HLSL 1
#include <ThirdParty/FidelityFX/ffx_a.h>

groupshared AU1 s_spdCounter;
groupshared AF1 s_spdIntermediateR[16][16];

AF4 SpdLoadSourceImage(AU2 p, AU1 slice)
{
	ANKI_MAYBE_UNUSED(slice);
	const U32 u = g_srcTex[p].r;
	return AF4(asfloat(u), 0.0, 0.0, 0.0);
}

AF4 SpdLoad(AU2 p, AU1 slice)
{
	ANKI_MAYBE_UNUSED(slice);
	const U32 u = g_dstUavs[5][p].r;
	return AF4(asfloat(u), 0.0, 0.0, 0.0);
}

void SpdStore(AU2 p, AF4 value, AU1 mip, AU1 slice)
{
	ANKI_MAYBE_UNUSED(slice);
	g_dstUavs[mip][p] = Vec4(asuint(value.x), 0.0, 0.0, 0.0);
}

void SpdIncreaseAtomicCounter(AU1 slice)
{
	ANKI_MAYBE_UNUSED(slice);
	InterlockedAdd(g_spdCounter[0], 1u, s_spdCounter);
}

AU1 SpdGetAtomicCounter()
{
	return s_spdCounter;
}

void SpdResetAtomicCounter(AU1 slice)
{
	ANKI_MAYBE_UNUSED(slice);
	g_spdCounter[0] = 0u;
}

AF4 SpdLoadIntermediate(AU1 x, AU1 y)
{
	return AF4(s_spdIntermediateR[x][y], 0.0, 0.0, 0.0);
}

void SpdStoreIntermediate(AU1 x, AU1 y, AF4 value)
{
	s_spdIntermediateR[x][y] = value.x;
}

AF4 SpdReduce4(AF4 v0, AF4 v1, AF4 v2, AF4 v3)
{
	const F32 minValue = min(v0.x, min(v1.x, min(v2.x, v3.x)));
	return AF4(minValue, 0.0, 0.0, 0.0);
}

#include <ThirdParty/FidelityFX/ffx_spd.h>

[numthreads(256, 1, 1)] void main(UVec3 svGroupId : SV_GROUPID, U32 svGroupIndex : SV_GROUPINDEX)
{
	const U32 slice = 0u;
	const UVec2 offset = UVec2(0, 0);
	SpdDownsample(AU2(svGroupId.xy), AU1(svGroupIndex), AU1(g_uniforms.m_mipmapCount), AU1(g_uniforms.m_threadGroupCount), slice, offset);
}

#pragma anki end
