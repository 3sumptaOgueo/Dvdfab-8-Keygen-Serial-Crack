// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// This shader draws tile aligned boxes in order to fill the HZB buffer for cascaded shadows

#include <AnKi/Shaders/Functions.hlsl>

#pragma anki start vert

[[vk::binding(0)]] Texture2D<Vec4> g_maxDepthRt;

struct Uniforms
{
	Mat4 m_reprojectionMat;
};

[[vk::push_constant]] ConstantBuffer<Uniforms> g_unis;

Vec4 main(U32 svVertexId : SV_VERTEXID, U32 svInstanceId : SV_INSTANCEID) : SV_POSITION
{
	UVec2 maxDepthRtSize;
	g_maxDepthRt.GetDimensions(maxDepthRtSize.x, maxDepthRtSize.y);

	const U32 tileX = svInstanceId % maxDepthRtSize.x;
	const U32 tileY = svInstanceId / maxDepthRtSize.x;

	const F32 maxDepth = g_maxDepthRt[UVec2(tileX, tileY)].x;

	// Z
	Vec3 ndc;
	ndc.z = (svVertexId <= 1) ? 0.0 : maxDepth;

	// X
	ndc.x = F32(tileX);
	if(svVertexId == 1 || svVertexId == 2)
	{
		// Right side, move the point
		ndc.x += 1.0f;
	}
	ndc.x /= F32(maxDepthRtSize.x);

	// Y
	ndc.y = F32(tileY) / F32(maxDepthRtSize.y);

	ndc.xy = uvToNdc(saturate(ndc.xy));

	// Unproject and project
	return mul(g_unis.m_reprojectionMat, Vec4(ndc, 1.0));
}

#pragma anki end

#pragma anki start frag

void main()
{
}

#pragma anki end
