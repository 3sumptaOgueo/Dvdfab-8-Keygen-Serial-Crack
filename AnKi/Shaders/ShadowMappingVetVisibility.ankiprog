// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// A very simle compute shader that checks if the light shadows needs rendering or not.

#pragma anki technique_start comp

#include <AnKi/Shaders/Common.hlsl>
#include <AnKi/Shaders/Include/GpuVisibilityTypes.h>
#include <AnKi/Shaders/Include/GpuSceneTypes.h>

StructuredBuffer<GpuVisibilityHash> g_hash : register(t0);
RWStructuredBuffer<U32> g_mdiDrawCounts : register(u0);
RWStructuredBuffer<GpuSceneLight> g_lights : register(u1);
RWStructuredBuffer<GpuSceneLightVisibleRenderablesHash> g_lightHashes : register(u2);
RWStructuredBuffer<DrawIndirectArgs> g_clearTileIndirectArgs : register(u3);
RWStructuredBuffer<DispatchIndirectArgs> g_taskShaderIndirectArgs : register(u4);

struct Uniforms
{
	U32 m_lightIndex;
	U32 m_padding0;
	U32 m_padding1;
	U32 m_padding2;
};

ANKI_PUSH_CONSTANTS(Uniforms, g_unis)

groupshared U32 s_renderLight;

[numthreads(64, 1, 1)] void main(U32 svGroupIndex : SV_GROUPINDEX)
{
	if(svGroupIndex == 0)
	{
		const GpuSceneLight light = g_lights[g_unis.m_lightIndex];
		const U32 crntHash = g_lightHashes[light.m_visibleRenderablesHashIndex].m_hash;
		s_renderLight = crntHash != g_hash[0].m_renderablesHash || g_hash[0].m_containsDeformable == 1;

		if(s_renderLight)
		{
			g_lightHashes[light.m_visibleRenderablesHashIndex].m_hash = g_hash[0].m_renderablesHash;

			g_clearTileIndirectArgs[0] = (DrawIndirectArgs)0;
			g_clearTileIndirectArgs[0].m_vertexCount = 3;
			g_clearTileIndirectArgs[0].m_instanceCount = 1;
		}
		else
		{
			g_clearTileIndirectArgs[0] = (DrawIndirectArgs)0;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if(s_renderLight == 0)
	{
		// Won't render, nullify MDI counts

		U32 renderStateBucketCount, unused;
		g_mdiDrawCounts.GetDimensions(renderStateBucketCount, unused);
		ANKI_ASSERT(renderStateBucketCount <= 64);

		if(svGroupIndex < renderStateBucketCount)
		{
			g_mdiDrawCounts[svGroupIndex] = 0u;
		}

		// Do the same for the task shaders
		g_taskShaderIndirectArgs.GetDimensions(renderStateBucketCount, unused);
		ANKI_ASSERT(renderStateBucketCount <= 64);

		if(svGroupIndex < renderStateBucketCount)
		{
			g_taskShaderIndirectArgs[svGroupIndex].m_threadGroupCountX = 0u;
		}
	}
}

#pragma anki technique_end comp
