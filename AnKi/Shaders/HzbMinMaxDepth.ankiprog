// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#include <AnKi/Shaders/Functions.hlsl>

#pragma anki start comp

[[vk::binding(0)]] Texture2D<Vec4> g_depthRt;
[[vk::binding(1)]] SamplerState g_nearestAnyClampSampler;
[[vk::binding(2)]] RWTexture2D<Vec4> g_minMaxDepthUav;

#define TILE_SIZE 64
#define THREADGROUP_SIZE_XY 16
#define MIN_POSSIBLE_WAVE_SIZE 8
constexpr U32 kSharedMemoryEntries = THREADGROUP_SIZE_XY * THREADGROUP_SIZE_XY / MIN_POSSIBLE_WAVE_SIZE;

groupshared F32 s_minDepths[kSharedMemoryEntries];
groupshared F32 s_maxDepths[kSharedMemoryEntries];
groupshared U32 s_waveIndexInsideThreadGroup;

[numthreads(THREADGROUP_SIZE_XY, THREADGROUP_SIZE_XY, 1)] void main(UVec2 svDispatchThreadId : SV_DISPATCHTHREADID, U32 svGroupIndex : SV_GROUPINDEX,
																	UVec2 svGroupId : SV_GROUPID)
{
	Vec2 depthRtSize;
	g_depthRt.GetDimensions(depthRtSize.x, depthRtSize.y);

	const U32 pixelsPerAxisPerThread = TILE_SIZE / THREADGROUP_SIZE_XY;

	const Vec2 uv = (Vec2(svDispatchThreadId * pixelsPerAxisPerThread) + 0.5) / depthRtSize;

	F32 minDepth = 2.0f;
	F32 maxDepth = -1.0f;
	[unroll] for(U32 x = 0; x < pixelsPerAxisPerThread; x++)
	{
		[unroll] for(U32 y = 0; y < pixelsPerAxisPerThread; y++)
		{
			const F32 depth = g_depthRt.SampleLevel(g_nearestAnyClampSampler, uv, 0.0f, IVec2(x, y));
			minDepth = min(minDepth, depth);
			maxDepth = max(maxDepth, depth);
		}
	}

	U32 wavesPerThreadGroup;
	U32 waveIndexInsideThreadGroup;
	ANKI_COMPUTE_WAVE_INDEX_INSIDE_THREADGROUP(svGroupIndex, s_waveIndexInsideThreadGroup, waveIndexInsideThreadGroup, wavesPerThreadGroup);

	const F32 waveMinDepth = WaveActiveMin(minDepth);
	const F32 waveMaxDepth = WaveActiveMax(maxDepth);

	if(WaveIsFirstLane())
	{
		s_minDepths[waveIndexInsideThreadGroup] = waveMinDepth;
		s_maxDepths[waveIndexInsideThreadGroup] = waveMaxDepth;
	}

	GroupMemoryBarrierWithGroupSync();

	if(svGroupIndex == 0)
	{
		F32 threadGroupMin = s_minDepths[0];
		F32 threadGroupMax = s_maxDepths[0];
		for(U32 i = 1; i < wavesPerThreadGroup; ++i)
		{
			threadGroupMin = min(threadGroupMin, s_minDepths[i]);
			threadGroupMax = min(threadGroupMax, s_maxDepths[i]);
		}

		g_minMaxDepthUav[svGroupId] = Vec4(threadGroupMin, threadGroupMax, 0.0, 0.0);
	}
}

#pragma anki end
