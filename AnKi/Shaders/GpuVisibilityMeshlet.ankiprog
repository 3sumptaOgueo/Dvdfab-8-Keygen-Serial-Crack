// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator HZB_TEST 0 1

#pragma anki technique_start comp

#include <AnKi/Shaders/Common.hlsl>
#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/VisibilityAndCollisionFunctions.hlsl>
#include <AnKi/Shaders/PackFunctions.hlsl>

#define MESHLET_BACKFACE_CULLING 1
#define MESHLET_OUTSIDE_OF_SCREEN_CULLING 1
#define MESHLET_NO_SAMPLING_POINT_CULLING 1
#define MESHLET_HZB_CULLING HZB_TEST

#define THREADGROUP_SIZE ANKI_TASK_SHADER_THREADGROUP_SIZE

[[vk::binding(0)]] StructuredBuffer<GpuSceneTaskShaderPayload> g_taskShaderPayloads;
[[vk::binding(1)]] StructuredBuffer<GpuSceneRenderable> g_renderables;
[[vk::binding(2)]] StructuredBuffer<GpuSceneMeshLod> g_meshLods;
[[vk::binding(3)]] ByteAddressBuffer g_gpuScene;
[[vk::binding(4)]] StructuredBuffer<MeshletBoundingVolume> g_meshletBoundingVolumes;
[[vk::binding(5)]] RWStructuredBuffer<DrawIndirectArgs> g_indirectDrawArg;
[[vk::binding(6)]] RWStructuredBuffer<GpuSceneMeshletInstance> g_drawInstances;
[[vk::binding(7)]] Texture2D<Vec4> g_hzbTexture;
[[vk::binding(8)]] SamplerState g_nearestClampSampler;

struct MaterialGlobalConstants
{
	Mat4 m_viewProjectionMatrix;
	Mat3x4 m_cameraTransform;

	Vec2 m_viewportSizef;
	U32 m_firstPayload;
	U32 m_padding;
};
[[vk::push_constant]] ConstantBuffer<MaterialGlobalConstants> g_consts;

[numthreads(THREADGROUP_SIZE, 1, 1)] void main(U32 svDispatchThreadId : SV_DISPATCHTHREADID, U32 svGroupId : SV_GROUPID,
											   U32 svGroupIndex : SV_GROUPINDEX)
{
	const GpuSceneTaskShaderPayload inPayload = g_taskShaderPayloads[g_consts.m_firstPayload + svGroupId];

	const U32 lod = inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit >> 30u;
	const U32 renderableIdx = (inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit >> 9u) & ((1u << 21u) - 1u);
	const U32 meshletGroup = inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit & ((1u << 9u) - 1u);

	const GpuSceneRenderable renderable = g_renderables[renderableIdx];
	const GpuSceneMeshLod meshLod = g_meshLods[renderable.m_meshLodsIndex + lod];
	U32 firstMeshletBoundingVolume = meshletGroup * kMeshletGroupSize;
	const U32 meshletCount = min(kMeshletGroupSize, meshLod.m_meshletCount - firstMeshletBoundingVolume);
	firstMeshletBoundingVolume += meshLod.m_firstMeshletBoundingVolume;
	const U32 firstMeshletGeometryDescriptor = meshletGroup * kMeshletGroupSize + meshLod.m_firstMeshletGeometryDescriptor;

	// Meshlet culling
	if(svGroupIndex < meshletCount)
	{
		Bool cull = false;

		const MeshletBoundingVolume meshletBoundingVol = g_meshletBoundingVolumes[firstMeshletBoundingVolume + svGroupIndex];
		const Mat3x4 worldTransform = g_gpuScene.Load<Mat3x4>(renderable.m_worldTransformsOffset);

#if MESHLET_BACKFACE_CULLING
		const Vec4 coneDirAndAng = unpackSnorm4x8(meshletBoundingVol.m_coneDirection_R8G8B8_Snorm_cosHalfAngle_R8_Snorm);
		cull = cullBackfaceMeshlet(coneDirAndAng.xyz, coneDirAndAng.w, meshletBoundingVol.m_coneApex, worldTransform,
								   g_consts.m_cameraTransform.getTranslationPart());
#endif

		const Mat4 wordTransform4 = {worldTransform.m_row0, worldTransform.m_row1, worldTransform.m_row2, Vec4(0.0f, 0.0f, 0.0f, 1.0f)};
		const Mat4 mvp = mul(g_consts.m_viewProjectionMatrix, wordTransform4);

		Vec2 minNdc, maxNdc;
		F32 aabbMinDepth;
		projectAabb(meshletBoundingVol.m_aabbMin, meshletBoundingVol.m_aabbMax, mvp, minNdc, maxNdc, aabbMinDepth);

#if MESHLET_OUTSIDE_OF_SCREEN_CULLING
		// Outside of the screen
		cull = cull || (any(minNdc > 1.0f) || any(maxNdc < -1.0f));
#endif

#if MESHLET_NO_SAMPLING_POINT_CULLING
		// Sampling points test
		const Vec2 windowCoordsMin = ndcToUv(minNdc) * g_consts.m_viewportSizef;
		const Vec2 windowCoordsMax = ndcToUv(maxNdc) * g_consts.m_viewportSizef;
		cull = cull || any(round(windowCoordsMin) == round(windowCoordsMax));
#endif

#if MESHLET_HZB_CULLING
		cull = cull || (renderable.m_boneTransformsOffset == 0u && cullHzb(minNdc, maxNdc, aabbMinDepth, g_hzbTexture, g_nearestClampSampler));
#endif

		if(!cull)
		{
			U32 instanceIdx;
			InterlockedAdd(g_indirectDrawArg[0].m_instanceCount, 1u, instanceIdx);

			if(instanceIdx == 0u)
			{
				g_indirectDrawArg[0].m_vertexCount = kMaxPrimitivesPerMeshlet * 3u;
			}

			GpuSceneMeshletInstance instance;
			instance.m_worldTransformsOffset = renderable.m_worldTransformsOffset;
			instance.m_constantsOffset = renderable.m_constantsOffset;
			instance.m_meshletGeometryDescriptorIndex = firstMeshletGeometryDescriptor + svGroupIndex;
			instance.m_boneTransformsOrParticleEmitterOffset =
				(renderable.m_particleEmitterOffset) ? renderable.m_particleEmitterOffset : renderable.m_boneTransformsOffset;

			g_drawInstances[instanceIdx] = instance;
		}
	}
}

#pragma anki technique_end comp
