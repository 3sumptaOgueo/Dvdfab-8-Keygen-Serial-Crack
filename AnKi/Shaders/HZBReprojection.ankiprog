// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki start comp

#include <AnKi/Shaders/Common.hlsl>

[[vk::binding(0)]] Texture2D g_inputDepthTex;
[[vk::binding(1), vk::image_format("r32ui")]] RWTexture2D<U32> g_HZBUAVTex;

[[vk::push_constant]] ConstantBuffer<Mat4> g_reprojectionMat;

[numthreads(8, 8, 1)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	UVec2 inputDepthTexSize;
	g_inputDepthTex.GetDimensions(inputDepthTexSize.x, inputDepthTexSize.y);

	if(any(svDispatchThreadId.xy >= inputDepthTexSize))
	{
		return;
	}

	const F32 depth = g_inputDepthTex[svDispatchThreadId.xy].r;
	const Vec2 uv = (Vec2(svDispatchThreadId.xy) + 0.5) / Vec2(inputDepthTexSize);
	const Vec2 ndc = uvToNdc(uv);

	// Reproject
	const Vec4 v4 = mul(g_reprojectionMat, Vec4(ndc, depth, 1.0));
	const Vec2 newNdc = v4.xy / v4.w;
	const Vec2 newUv = ndcToUv(newNdc);

	// Store
	Vec2 HZBTexSize;
	g_HZBUAVTex.GetDimensions(HZBTexSize.x, HZBTexSize.y);
	const Vec2 texCoordsf = newUv * HZBTexSize;
	if(any(texCoordsf < Vec2(0.0f, 0.0f)) || any(texCoordsf >= HZBTexSize))
	{
		return;
	}

	InterlockedMax(g_HZBUAVTex[IVec2(texCoordsf)], asuint(depth));
}

#pragma anki end
