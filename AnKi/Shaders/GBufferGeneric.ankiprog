// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator ANKI_VELOCITY 0 1
#pragma anki mutator ANKI_TECHNIQUE 0 1
#pragma anki mutator ANKI_BONES 0 1
#pragma anki mutator DIFFUSE_TEX 0 1
#pragma anki mutator SPECULAR_TEX 0 1
#pragma anki mutator ROUGHNESS_TEX 0 1
#pragma anki mutator METAL_TEX 0 1
#pragma anki mutator NORMAL_TEX 0 1
#pragma anki mutator PARALLAX 0 1
#pragma anki mutator EMISSIVE_TEX 0 1
#pragma anki mutator ALPHA_TEST 0 1

#pragma anki skip_mutation ALPHA_TEST 1 DIFFUSE_TEX 0
#pragma anki skip_mutation ANKI_VELOCITY 1 ANKI_TECHNIQUE 1

// Some defines the clear up things
#define REALLY_ALPHA_TEST (ALPHA_TEST && DIFFUSE_TEX)
#define UVS (ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER || REALLY_ALPHA_TEST)
#define REALLY_VELOCITY ((ANKI_VELOCITY || ANKI_BONES) && ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER)
#define REALLY_USING_PARALLAX (PARALLAX == 1 && ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER && ALPHA_TEST == 0)

#define MESHLET_BACKFACE_CULLING 0

#include <AnKi/Shaders/Include/MaterialTypes.h>
#include <AnKi/Shaders/Include/GpuSceneFunctions.h>
#include <AnKi/Shaders/PackFunctions.hlsl>
#include <AnKi/Shaders/Functions.hlsl>
#include <AnKi/Shaders/MaterialShadersCommon.hlsl>

#pragma anki reflect AnKiLocalConstants
#pragma anki struct AnKiLocalConstants

#pragma anki member RVec3 m_diffColor if DIFFUSE_TEX is 0
#pragma anki member U32 m_diffTex if DIFFUSE_TEX is 1

#pragma anki member U32 m_normalTex if NORMAL_TEX is 1

#pragma anki member RF32 m_roughness if ROUGHNESS_TEX is 0
#pragma anki member U32 m_roughnessTex if ROUGHNESS_TEX is 1

#pragma anki member RVec3 m_specColor if SPECULAR_TEX is 0
#pragma anki member U32 m_specTex if SPECULAR_TEX is 1

#pragma anki member RF32 m_metallic if METAL_TEX is 0
#pragma anki member U32 m_metallicTex if METAL_TEX is 1

#pragma anki member RVec3 m_emission if EMISSIVE_TEX is 0
#pragma anki member U32 m_emissiveTex if EMISSIVE_TEX is 1

#pragma anki member RF32 m_heightmapScale if PARALLAX is 1
#pragma anki member U32 m_heightTex if PARALLAX is 1

#pragma anki member RF32 m_subsurface

#pragma anki struct end

struct VertIn
{
	U32 m_svVertexId : SV_VERTEXID;
	[[vk::location(0)]] UVec4 m_gpuSceneRenderable : RENDERABLE;
};

struct VertOut
{
	Vec4 m_svPosition : SV_POSITION;

#if UVS
	Vec2 m_uv : TEXCOORD;
#endif

#if REALLY_VELOCITY
	Vec3 m_prevClipXyw : PREV_CLIP;
	Vec3 m_crntClipXyw : CRNT_CLIP;
#endif

#if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
	Vec3 m_worldPos : WORLD_POS;
	RVec3 m_normal : NORMAL;
#endif

	nointerpolation U32 m_constantsOffset : UNIS_OFFSET;
};

#if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
struct FragOut
{
	Vec4 m_color0 : SV_TARGET0;
	Vec4 m_color1 : SV_TARGET1;
	Vec4 m_color2 : SV_TARGET2;
	Vec2 m_color3 : SV_TARGET3;
};
#endif

struct MeshShaderPayload
{
	U32 m_firstMeshletIndex;
	U32 m_visibleMeshletsRelativeIndices[kMeshletGroupSize / sizeof(U32)];
	U32 m_worldTransformsOffset;
	U32 m_constantsOffset;
	U32 m_boneTransformsOrParticleEmitterOffset;
	Vec3 m_positionTranslation;
	F32 m_positionScale;
};

struct Mat3x4_2
{
	Mat3x4 m_a;
	Mat3x4 m_b;
};

Mat3x4_2 loadBoneTransforms(UnpackedMeshVertex vert, U32 boneTransformsOffset, U32 index)
{
	const U32 boneIdx = vert.m_boneIndices[index];
	U32 byteOffset = boneTransformsOffset;
	byteOffset += boneIdx * sizeof(Mat3x4) * 2;
	return g_gpuScene.Load<Mat3x4_2>(byteOffset);
}

#if ANKI_BONES
void skinning(UnpackedMeshVertex vert, U32 boneTransformsOffset, inout Vec3 pos, inout Vec3 prevPos, inout RVec3 normal)
{
	Mat3x4_2 mats = loadBoneTransforms(vert, boneTransformsOffset, 0);

	Mat3x4 skinMat = mats.m_a * vert.m_boneWeights[0];
	Mat3x4 prevSkinMat = mats.m_b * vert.m_boneWeights[0];

	[unroll] for(U32 i = 1u; i < 4u; ++i)
	{
		mats = loadBoneTransforms(vert, boneTransformsOffset, i);

		skinMat = skinMat + mats.m_a * vert.m_boneWeights[i];
		prevSkinMat = prevSkinMat + mats.m_b * vert.m_boneWeights[i];
	}

#	if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
	prevPos = mul(prevSkinMat, Vec4(pos, 1.0)).xyz;
	normal = mul(skinMat, Vec4(normal, 0.0)).xyz;
#	endif
	ANKI_MAYBE_UNUSED(prevPos);
	ANKI_MAYBE_UNUSED(normal);

	pos = mul(skinMat, Vec4(pos, 1.0)).xyz;
}
#endif

#if(ANKI_VELOCITY || ANKI_BONES) && ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
void velocity(Mat3x4 worldTransform, Mat3x4 prevWorldTransform, Vec3 prevLocalPos, inout VertOut output)
{
	ANKI_MAYBE_UNUSED(prevWorldTransform);
	ANKI_MAYBE_UNUSED(worldTransform);

#	if ANKI_VELOCITY
	// Object is also moving
	const Mat3x4 trf = prevWorldTransform;
#	else
	// Object is a skin that is not moving
	const Mat3x4 trf = worldTransform;
#	endif

	Vec4 v4 = Vec4(mul(trf, Vec4(prevLocalPos, 1.0)), 1.0);
	v4 = mul(g_globalConstants.m_previousViewProjectionMatrix, v4);

	output.m_prevClipXyw = v4.xyw;
	output.m_crntClipXyw = output.m_svPosition.xyw;
}
#endif

#pragma anki start vert

VertOut main(VertIn input)
{
	VertOut output;

	const GpuSceneRenderableVertex renderable = unpackGpuSceneRenderableVertex(input.m_gpuSceneRenderable);
	const GpuSceneMeshLod mesh = g_gpuScene.Load<GpuSceneMeshLod>(renderable.m_meshLodOffset);
	UnpackedMeshVertex vert = loadVertex(mesh, input.m_svVertexId, ANKI_BONES);

	const Mat3x4 worldTransform = g_gpuScene.Load<Mat3x4>(renderable.m_worldTransformsOffset);
	const Mat3x4 prevWorldTransform = g_gpuScene.Load<Mat3x4>(renderable.m_worldTransformsOffset + sizeof(Mat3x4));
	ANKI_MAYBE_UNUSED(prevWorldTransform);

#if UVS
	output.m_uv = vert.m_uv;
#endif
	Vec3 prevPos = vert.m_position;
	ANKI_MAYBE_UNUSED(prevPos);
	output.m_constantsOffset = renderable.m_constantsOffset;

	// Do stuff
#if ANKI_BONES
	skinning(vert, renderable.m_boneTransformsOrParticleEmitterOffset, vert.m_position, prevPos, vert.m_normal);
#endif

	const Vec3 worldPos = mul(worldTransform, Vec4(vert.m_position, 1.0));
	output.m_svPosition = mul(g_globalConstants.m_viewProjectionMatrix, Vec4(worldPos, 1.0));

#if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
	output.m_worldPos = worldPos;
	output.m_normal = mul(worldTransform, Vec4(vert.m_normal, 0.0));
#endif

#if REALLY_VELOCITY
	velocity(worldTransform, prevWorldTransform, prevPos, output);
#endif

	return output;
};

#pragma anki end vert

#pragma anki start task

groupshared MeshShaderPayload s_payload;
groupshared U32 s_visibleMeshletCount;

struct FirstPayload
{
	UVec4 m_val;
};

[[vk::push_constant]] ConstantBuffer<FirstPayload> g_firstPayload;

[numthreads(ANKI_TASK_SHADER_THREADGROUP_SIZE, 1, 1)] void main(U32 svGroupId : SV_GROUPID, U32 svGroupIndex : SV_GROUPINDEX)
{
	const GpuSceneTaskShaderPayload inPayload = g_taskShaderPayloads[g_firstPayload.m_val.x + svGroupId];

	const U32 lod = inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit >> 30u;
	const U32 renderableIdx = (inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit >> 9u) & ((1u << 21u) - 1u);
	const U32 meshletGroup = inPayload.m_lod_2bit_renderableIdx_21bit_meshletGroup_9bit & ((1u << 9u) - 1u);

	const GpuSceneRenderable renderable = g_renderables[renderableIdx];
	const GpuSceneMeshLod meshLod = g_gpuScene.Load<GpuSceneMeshLod>(renderable.m_meshLodsOffset + sizeof(GpuSceneMeshLod) * lod);
	U32 firstMeshlet = meshletGroup * kMeshletGroupSize;
	const U32 meshletCount = min(kMeshletGroupSize, meshLod.m_meshletCount - firstMeshlet * kMeshletGroupSize);
	firstMeshlet += meshLod.m_firstMeshlet;

	if(svGroupIndex == 0u)
	{
		s_payload.m_firstMeshletIndex = firstMeshlet;
		s_payload.m_worldTransformsOffset = renderable.m_worldTransformsOffset;
		s_payload.m_constantsOffset = renderable.m_constantsOffset;
		s_payload.m_boneTransformsOrParticleEmitterOffset = renderable.m_boneTransformsOffset;
		s_payload.m_positionScale = meshLod.m_positionScale;
		s_payload.m_positionTranslation = meshLod.m_positionTranslation;

		s_visibleMeshletCount = 0;

		[unroll] for(U32 i = 0; i < kMeshletGroupSize / sizeof(U32); ++i)
		{
			s_payload.m_visibleMeshletsRelativeIndices[i] = 0u;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if(svGroupIndex < meshletCount)
	{
		Bool cull = false;

#if MESHLET_BACKFACE_CULLING
		const Meshlet meshlet = g_meshlets[firstMeshlet + svGroupIndex];
		const Vec4 coneData = unpackSnorm4x8(meshlet.m_coneDirection_R8G8B8_Snorm_minusSinAngle_R8_Snorm);

		const Mat3x4 worldTransform = g_gpuScene.Load<Mat3x4>(renderable.m_worldTransformsOffset);

		const Vec3 meshletCenterWspace = mul(worldTransform, Vec4(meshlet.m_sphereCenter, 1.0f));
		const Vec3 coneAxisWspace = normalize(mul(worldTransform, Vec4(coneData.xyz, 0.0f)));
		const Vec3 cameraPos = Vec3(g_globalConstants.m_cameraTransform.m_row0.w, g_globalConstants.m_cameraTransform.m_row1.w,
									g_globalConstants.m_cameraTransform.m_row2.w);
		const Vec3 viewDir = normalize(meshletCenterWspace - cameraPos);

		cull = cull || dot(coneAxisWspace, -viewDir) < coneData.w;
#endif

		if(!cull)
		{
			U32 idx;
			InterlockedAdd(s_visibleMeshletCount, 1u, idx);

			const U32 groupIdx = idx / 4u;
			const U32 localIdx = idx % 4u;

			const U32 mask = svGroupIndex << (localIdx * 8u);
			InterlockedOr(s_payload.m_visibleMeshletsRelativeIndices[groupIdx], mask);
		}
	}

	DispatchMesh(s_visibleMeshletCount, 1, 1, s_payload);
}

#pragma anki end task

#pragma anki start mesh

constexpr U32 g_dummy = 0; // The formater is getting confused so add this

[numthreads(ANKI_MESH_SHADER_THREADGROUP_SIZE, 1, 1)] [outputtopology("triangle")] void
main(in payload MeshShaderPayload payload, out vertices VertOut verts[kMaxVerticesPerMeshlet], out indices UVec3 indices[kMaxPrimitivesPerMeshlet],
	 U32 svGroupId : SV_GROUPID, U32 svGroupIndex : SV_GROUPINDEX)
{
	const U32 groupIdx = svGroupId / 4u;
	const U32 localIdx = svGroupId % 4u;
	const U32 relativeMeshletIdx = (payload.m_visibleMeshletsRelativeIndices[groupIdx] >> (localIdx * 8u)) & 0xFFu;

	const Meshlet meshlet = g_meshlets[payload.m_firstMeshletIndex + relativeMeshletIdx];
	const U32 primCount = meshlet.m_primitiveCount_R16_Uint_vertexCount_R16_Uint >> 16u;
	const U32 vertCount = meshlet.m_primitiveCount_R16_Uint_vertexCount_R16_Uint & 0xFFFFu;

	SetMeshOutputCounts(vertCount, primCount);

	// Write the verts
	const U32 vertLoopCount = kMaxVerticesPerMeshlet / ANKI_MESH_SHADER_THREADGROUP_SIZE;
	[unroll] for(U32 l = 0; l < vertLoopCount; ++l)
	{
		const U32 idx = l * ANKI_MESH_SHADER_THREADGROUP_SIZE + svGroupIndex;

		if(idx < vertCount)
		{
			VertOut output;

			UnpackedMeshVertex vert = loadVertex(meshlet, idx, ANKI_BONES, payload.m_positionScale, payload.m_positionTranslation);

			const Mat3x4 worldTransform = g_gpuScene.Load<Mat3x4>(payload.m_worldTransformsOffset);
			const Mat3x4 prevWorldTransform = g_gpuScene.Load<Mat3x4>(payload.m_worldTransformsOffset + sizeof(Mat3x4));
			ANKI_MAYBE_UNUSED(prevWorldTransform);

#if UVS
			output.m_uv = vert.m_uv;
#endif
			Vec3 prevPos = vert.m_position;
			ANKI_MAYBE_UNUSED(prevPos);
			output.m_constantsOffset = payload.m_constantsOffset;

			// Do stuff
#if ANKI_BONES
			skinning(vert, payload.m_boneTransformsOrParticleEmitterOffset, vert.m_position, prevPos, vert.m_normal);
#endif

			const Vec3 worldPos = mul(worldTransform, Vec4(vert.m_position, 1.0));
			output.m_svPosition = mul(g_globalConstants.m_viewProjectionMatrix, Vec4(worldPos, 1.0f));

#if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER
			output.m_worldPos = worldPos;
			output.m_normal = mul(worldTransform, Vec4(vert.m_normal, 0.0));
#endif

#if REALLY_VELOCITY
			velocity(worldTransform, prevWorldTransform, prevPos, output);
#endif

			verts[idx] = output;
		}
	}

	// Write the indices
	const U32 primLoopCount = kMaxPrimitivesPerMeshlet / ANKI_MESH_SHADER_THREADGROUP_SIZE;
	[unroll] for(U32 l = 0; l < primLoopCount; ++l)
	{
		const U32 idx = l * ANKI_MESH_SHADER_THREADGROUP_SIZE + svGroupIndex;

		if(idx < primCount)
		{
			indices[idx] = g_unifiedGeom_R8G8B8A8_Uint[meshlet.m_firstPrimitive + idx].xyz;
		}
	}
}

#pragma anki end mesh

#pragma anki start frag

void doAlphaTest(RF32 alpha)
{
	if(alpha == 0.0)
	{
		discard;
	}
}

#if ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_DEPTH
void main(VertOut input)
{
	ANKI_MAYBE_UNUSED(input);
#	if REALLY_ALPHA_TEST
	const AnKiLocalConstants localConstants = loadAnKiLocalConstants(g_gpuScene, input.m_constantsOffset);
	const RVec4 diffColorA = g_bindlessTextures2dF32[localConstants.m_diffTex].Sample(g_globalSampler, input.m_uv);
	doAlphaTest(diffColorA.a);
#	endif
}

#elif ANKI_TECHNIQUE == ANKI_RENDERING_TECHNIQUE_GBUFFER

FragOut main(VertOut input)
{
	const AnKiLocalConstants localConstants = loadAnKiLocalConstants(g_gpuScene, input.m_constantsOffset);

#	if REALLY_USING_PARALLAX
	// TODO
	const Vec2 uv = input.m_uv;
#	else
	const Vec2 uv = input.m_uv;
#	endif
	ANKI_MAYBE_UNUSED(uv);

#	if DIFFUSE_TEX
#		if REALLY_ALPHA_TEST
	const RVec4 diffColorA = g_bindlessTextures2dF32[localConstants.m_diffTex].Sample(g_globalSampler, uv);
	doAlphaTest(diffColorA.a);
	const RVec3 diffColor = diffColorA.rgb;
#		else
	const RVec3 diffColor = g_bindlessTextures2dF32[localConstants.m_diffTex].Sample(g_globalSampler, uv).rgb;
#		endif
#	else
	const RVec3 diffColor = localConstants.m_diffColor;
#	endif

#	if SPECULAR_TEX
	const RVec3 specColor = g_bindlessTextures2dF32[localConstants.m_specTex].Sample(g_globalSampler, uv).rgb;
#	else
	const RVec3 specColor = localConstants.m_specColor;
#	endif

#	if ROUGHNESS_TEX
	const RF32 roughness = g_bindlessTextures2dF32[localConstants.m_roughnessTex].Sample(g_globalSampler, uv).g;
#	else
	const RF32 roughness = localConstants.m_roughness;
#	endif

#	if METAL_TEX
	const RF32 metallic = g_bindlessTextures2dF32[localConstants.m_metallicTex].Sample(g_globalSampler, uv).b;
#	else
	const RF32 metallic = localConstants.m_metallic;
#	endif

#	if NORMAL_TEX
	const RVec3 nAtTangentspace = normalize((g_bindlessTextures2dF32[localConstants.m_normalTex].Sample(g_globalSampler, uv).rgb - 0.5) * 2.0);
	const Vec3 viewDir = normalize(g_globalConstants.m_cameraTransform.getTranslationPart() - input.m_worldPos);
	const RVec3 normal = perturbNormal(nAtTangentspace, viewDir, uv, normalize(input.m_normal));
#	else
	const RVec3 normal = normalize(input.m_normal);
#	endif

#	if EMISSIVE_TEX
	const RVec3 emission = g_bindlessTextures2dF32[localConstants.m_emissiveTex].Sample(g_globalSampler, uv).rgb;
#	else
	const RVec3 emission = localConstants.m_emission;
#	endif

#	if ANKI_VELOCITY || ANKI_BONES
	const Vec2 prevNdc = input.m_prevClipXyw.xy / input.m_prevClipXyw.z;
	const Vec2 crntNdc = input.m_crntClipXyw.xy / input.m_crntClipXyw.z;

	// It's ndcToUv(prevNdc) - ndcToUv(crntNdc) or:
	const Vec2 velocity = (prevNdc - crntNdc) * 0.5;
#	else
	const Vec2 velocity = Vec2(1.0, 1.0);
#	endif

	GbufferInfo g;
	g.m_diffuse = diffColor;
	g.m_normal = normal;
	g.m_f0 = specColor;
	g.m_roughness = roughness;
	g.m_subsurface = localConstants.m_subsurface;
	g.m_emission = emission;
	g.m_metallic = metallic;
	g.m_velocity = velocity;

	FragOut output;
	packGBuffer(g, output.m_color0, output.m_color1, output.m_color2, output.m_color3);
	return output;
}
#endif

#pragma anki end frag
