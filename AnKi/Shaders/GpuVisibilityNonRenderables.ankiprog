// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator HZB_TEST 0 1
#pragma anki mutator OBJECT_TYPE 0 1 2 3 4 // Same as GpuSceneNonRenderableObjectType
#pragma anki mutator CPU_FEEDBACK 0 1

#pragma anki skip_mutation CPU_FEEDBACK 1 OBJECT_TYPE 1
#pragma anki skip_mutation CPU_FEEDBACK 1 OBJECT_TYPE 2

#pragma anki start comp

#include <AnKi/Shaders/Common.hlsl>
#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/Include/GpuVisibilityTypes.h>
#include <AnKi/Shaders/CollisionFunctions.hlsl>

#if OBJECT_TYPE == ANKI_GPU_SCENE_NON_RENDERABLE_OBJECT_TYPE_LIGHT
typedef GpuSceneLight ObjectType;
#elif OBJECT_TYPE == ANKI_GPU_SCENE_NON_RENDERABLE_OBJECT_TYPE_DECAL
typedef GpuSceneDecal ObjectType;
#elif OBJECT_TYPE == ANKI_GPU_SCENE_NON_RENDERABLE_OBJECT_TYPE_FOG_DENSITY_VOLUME
typedef GpuSceneFogDensityVolume ObjectType;
#elif OBJECT_TYPE == ANKI_GPU_SCENE_NON_RENDERABLE_OBJECT_TYPE_REFLECTION_PROBE
typedef GpuSceneReflectionProbe ObjectType;
#else
typedef GpuSceneGlobalIlluminationProbe ObjectType;
#endif

[[vk::binding(0)]] StructuredBuffer<ObjectType> g_objects;
[[vk::binding(1)]] ConstantBuffer<GpuVisibilityNonRenderableUniforms> g_unis;
[[vk::binding(2)]] RWStructuredBuffer<U32> g_visibleIndices; // 1st element is the count. What follows is indices

#if CPU_FEEDBACK
// 1st element is a count. What follows is an array of UUIDs.
[[vk::binding(3)]] RWStructuredBuffer<U32> g_cpuFeedbackBuffer;

// Contains 2 U32s. One that it gets cleared and another that will be incremented.
[[vk::binding(4)]] RWStructuredBuffer<U32> g_counterBuffer;
#endif

Vec4 getSphere(GpuSceneLight l)
{
	return Vec4(l.m_position, l.m_radius);
}

Vec4 getSphere(GpuSceneDecal l)
{
	return l.m_boundingSphere;
}

Vec4 getSphere(GpuSceneFogDensityVolume l)
{
	if(l.m_isBox)
	{
		const Vec3 center = (l.m_aabbMinOrSphereCenter + l.m_aabbMaxOrSphereRadius) / 2.0f;
		const F32 radius = length(l.m_aabbMaxOrSphereRadius - center);
		return Vec4(center, radius);
	}
	else
	{
		return Vec4(l.m_aabbMinOrSphereCenter, l.m_aabbMaxOrSphereRadius.x);
	}
}

Vec4 getSphere(GpuSceneReflectionProbe l)
{
	const Vec3 center = (l.m_aabbMin + l.m_aabbMax) / 2.0f;
	const F32 radius = length(center - l.m_aabbMax);
	return Vec4(center, radius);
}

Vec4 getSphere(GpuSceneGlobalIlluminationProbe l)
{
	const Vec3 center = (l.m_aabbMin + l.m_aabbMax) / 2.0f;
	const F32 radius = length(center - l.m_aabbMax);
	return Vec4(center, radius);
}

[numthreads(64, 1, 1)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	U32 objectCount, unused;
	g_objects.GetDimensions(objectCount, unused);

#if CPU_FEEDBACK
	// Zero feedback counters of the next frame
	if(svDispatchThreadId.x == 0)
	{
		g_counterBuffer[!g_unis.m_feedbackCounterIdx] = 0u;
	}
#endif

	if(svDispatchThreadId.x >= objectCount)
	{
		return;
	}

	// Frustum test
	//
	const ObjectType obj = g_objects[svDispatchThreadId.x];
	const Vec4 sphere = getSphere(obj);
	if(!frustumTest(g_unis.m_clipPlanes, sphere.xyz, sphere.w))
	{
		return;
	}

	// Add the object
	//
	U32 idx;
	InterlockedAdd(g_visibleIndices[0], 1, idx);
	g_visibleIndices[idx + 1] = svDispatchThreadId.x;

	// Give feedback to the CPU
	//
#if CPU_FEEDBACK
	if(obj.m_uuid != 0)
	{
		U32 idx;
		InterlockedAdd(g_counterBuffer[g_unis.m_feedbackCounterIdx], 1, idx);

		U32 dummy;
		InterlockedExchange(g_cpuFeedbackBuffer[0], idx + 1, dummy);
		g_cpuFeedbackBuffer[idx + 1] = obj.m_uuid;
	}
#endif
}

#pragma anki end
