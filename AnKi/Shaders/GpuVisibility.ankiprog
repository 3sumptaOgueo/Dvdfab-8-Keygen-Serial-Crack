// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator HZB_TEST 0 1

#pragma anki start comp

#include <AnKi/Shaders/Common.hlsl>
#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/Include/MiscRendererTypes.h>
#include <AnKi/Shaders/CollisionFunctions.hlsl>

// Buffers that point to the GPU scene
[[vk::binding(0)]] StructuredBuffer<GpuSceneRenderableAabb> g_aabbs;
[[vk::binding(1)]] StructuredBuffer<GpuSceneRenderable> g_renderables;
[[vk::binding(2)]] ByteAddressBuffer g_gpuScene;

// These 2 have the same size
[[vk::binding(3)]] RWStructuredBuffer<GpuSceneRenderable> g_instanceRateRenderables;
[[vk::binding(4)]] RWStructuredBuffer<DrawIndexedIndirectArgs> g_drawIndexedIndirectArgs;

// Index pointing to the above arrays. One for each render state bucket
[[vk::binding(5)]] StructuredBuffer<U32> g_drawIndirectArgsOffsets;
// The MDI counts. One for each render state bucket
[[vk::binding(6)]] RWStructuredBuffer<U32> g_mdiDrawCounts;

[[vk::binding(7)]] ConstantBuffer<GpuVisibilityUniforms> g_unis;

#if HZB_TEST
[[vk::binding(8)]] Texture2D<Vec4> g_hzbTex;
[[vk::binding(9)]] SamplerState g_nearestAnyClampSampler;
#endif

[numthreads(64, 1, 1)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	const U32 aabbIdx = svDispatchThreadId.x;
	if(aabbIdx >= g_unis.m_aabbCount)
	{
		return;
	}

	const GpuSceneRenderableAabb aabb = g_aabbs[aabbIdx];

	// Frustum test
	//
	F32 minPlaneDistance = testPlanePoint(g_unis.m_clipPlanes[0].xyz, g_unis.m_clipPlanes[0].w, aabb.m_sphereCenter);
	[unroll] for(U32 i = 1; i < 6; ++i)
	{
		const F32 d = testPlanePoint(g_unis.m_clipPlanes[i].xyz, g_unis.m_clipPlanes[i].w, aabb.m_sphereCenter);
		minPlaneDistance = min(minPlaneDistance, d);
	}

	if(minPlaneDistance <= aabb.m_negativeSphereRadius)
	{
		return;
	}

	// Screen-space AABB calculation and checking
	//
	const Vec3 A = aabb.m_sphereCenter - aabb.m_aabbExtend;
	const Vec3 B = aabb.m_sphereCenter + aabb.m_aabbExtend;
	const Vec3 aabbEdges[8u] = {Vec3(A.x, A.y, A.z), Vec3(B.x, A.y, A.z), Vec3(A.x, B.y, A.z), Vec3(A.x, A.y, B.z),
								Vec3(B.x, B.y, A.z), Vec3(B.x, A.y, B.z), Vec3(A.x, B.y, B.z), Vec3(B.x, B.y, B.z)};

	F32 aabbMinDepth = 1.0f;
	Vec2 minNdc = 1000.0f;
	Vec2 maxNdc = -1000.0f;
	[unroll] for(U32 i = 0; i < 8; ++i)
	{
		Vec4 p = mul(g_unis.m_viewProjectionMat, Vec4(aabbEdges[i], 1.0f));

		p.xyz /= abs(p.w);

		minNdc = min(minNdc, p.xy);
		maxNdc = max(maxNdc, p.xy);
		aabbMinDepth = min(aabbMinDepth, p.z);
	}

	aabbMinDepth = saturate(aabbMinDepth);
	if(any(minNdc > 1.0f) || any(maxNdc < -1.0f))
	{
		return;
	}

	// HiZ culling
	//

#if HZB_TEST
	// Compute the mip
	Vec2 texSize;
	F32 mipCount;
	g_hzbTex.GetDimensions(0, texSize.x, texSize.y, mipCount);

	const Vec2 minUv = saturate(ndcToUv(minNdc));
	const Vec2 maxUv = saturate(ndcToUv(maxNdc));
	const Vec2 sizeXY = (maxUv - minUv) * texSize;
	F32 mip = ceil(log2(max(sizeXY.x, sizeXY.y)));

#	if 0
	mip = clamp(mip, 0.0, mipCount - 1.0);
	const F32 levelLower = max(mip - 1.0, 0.0);
	const Vec2 scale = exp2(-levelLower);
	const Vec2 a = floor(minUv * scale);
	const Vec2 b = ceil(maxUv * scale);
	const Vec2 dims = b - a;

	if(dims.x <= 2.0 && dims.y <= 2.0)
	{
		mip = levelLower;
	}
#	endif

	// Sample mip
	Vec4 depths;
	depths[0] = g_hzbTex.SampleLevel(g_nearestAnyClampSampler, minUv, mip);
	depths[1] = g_hzbTex.SampleLevel(g_nearestAnyClampSampler, maxUv, mip);
	depths[2] = g_hzbTex.SampleLevel(g_nearestAnyClampSampler, Vec2(minUv.x, maxUv.y), mip);
	depths[3] = g_hzbTex.SampleLevel(g_nearestAnyClampSampler, Vec2(maxUv.x, minUv.y), mip);
	const F32 maxDepth = max4(depths);

	if(aabbMinDepth > maxDepth)
	{
		return;
	}
#endif

	// Compute the LOD
	//
	const F32 distFromLodPoint = length(aabb.m_sphereCenter - g_unis.m_lodReferencePoint) + aabb.m_negativeSphereRadius;

	U32 lod;
	if(distFromLodPoint < g_unis.m_maxLodDistances[0])
	{
		lod = 0u;
	}
	else if(distFromLodPoint < g_unis.m_maxLodDistances[1])
	{
		lod = 1u;
	}
	else
	{
		lod = 2u;
	}

	// Add the drawcall
	//
	const U32 renderStateBucket = aabb.m_renderableIndexAndRenderStateBucket & ((1u << 12u) - 1u);
	const U32 renderableIdx = aabb.m_renderableIndexAndRenderStateBucket >> 12u;

	U32 indirectIdx;
	InterlockedAdd(g_mdiDrawCounts[renderStateBucket], 1, indirectIdx);
	indirectIdx += g_drawIndirectArgsOffsets[renderStateBucket];

	const GpuSceneRenderable renderableIn = g_renderables[renderableIdx];
	const U32 meshLodOffset = renderableIn.m_geometryOffset + sizeof(GpuSceneMeshLod) * lod;
	const GpuSceneMeshLod meshLod = g_gpuScene.Load<GpuSceneMeshLod>(meshLodOffset);

	DrawIndexedIndirectArgs indirect;
	indirect.m_indexCount = meshLod.m_indexCount;
	indirect.m_instanceCount = 1;
	indirect.m_firstIndex = meshLod.m_firstIndex;
	indirect.m_vertexOffset = 0;
	indirect.m_firstInstance = indirectIdx;
	g_drawIndexedIndirectArgs[indirectIdx] = indirect;

	GpuSceneRenderable renderableOut = renderableIn;
	renderableOut.m_geometryOffset = meshLodOffset;
	g_instanceRateRenderables[indirectIdx] = renderableOut;
}

#pragma anki end
