// Copyright (C) 2009-2023, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki start comp

#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/Include/MiscRendererTypes.h>
#include <AnKi/Shaders/CollisionFunctions.hlsl>

// Buffers that point to the GPU scene
[[vk::binding(0)]] StructuredBuffer<GpuSceneRenderableAabb> g_aabbs;
[[vk::binding(1)]] StructuredBuffer<GpuSceneRenderable> g_renderables;
[[vk::binding(2)]] ByteAddressBuffer g_gpuScene;

[[vk::binding(3)]] Texture2D<U32> g_hiZTex;

// These 2 have the same size
[[vk::binding(4)]] RWStructuredBuffer<GpuSceneRenderable> g_instanceRateRenderables;
[[vk::binding(5)]] RWStructuredBuffer<DrawIndexedIndirectArgs> g_drawIndexedIndirectArgs;

// Index pointing to the above arrays. One for each render state bucket
[[vk::binding(6)]] StructuredBuffer<U32> g_drawIndirectArgsOffsets;
// The MDI counts. One for each render state bucket
[[vk::binding(7)]] RWStructuredBuffer<U32> g_mdiDrawCounts;

[[vk::binding(8)]] ConstantBuffer<GpuVisibilityUniforms> g_unis;

[numthreads(64, 1, 1)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	const U32 aabbIdx = svDispatchThreadId.x;
	if(aabbIdx >= g_unis.m_aabbCount)
	{
		return;
	}

	const GpuSceneRenderableAabb aabb = g_aabbs[aabbIdx];

	// Frustum test
	//
	F32 minPlaneDistance = 0.0f;
	[unroll] for(U32 i = 0; i < 6; ++i)
	{
		const F32 d = testPlanePoint(g_unis.m_clipPlanes[i].xyz, g_unis.m_clipPlanes[i].w, aabb.m_sphereCenter);
		minPlaneDistance = min(minPlaneDistance, d);
	}

	if(minPlaneDistance <= aabb.m_negativeSphereRadius)
	{
		return;
	}

	// TODO HiZ testing

	// Compute the LOD
	//
	const Vec4 nearPlane = g_unis.m_clipPlanes[0];
	const F32 distFromNearPlane = testPlaneSphere(nearPlane.xyz, nearPlane.w, aabb.m_sphereCenter, -aabb.m_negativeSphereRadius);

	U32 lod;
	if(distFromNearPlane < g_unis.m_maxLodDistances[0])
	{
		lod = 0u;
	}
	else if(distFromNearPlane < g_unis.m_maxLodDistances[1])
	{
		lod = 1u;
	}
	else
	{
		lod = 2u;
	}
	// Add the drawcall
	//
	const U32 renderStateBucket = aabb.m_renderableIndexAndRenderStateBucket & ((1u << 12u) - 1u);
	const U32 renderableIdx = aabb.m_renderableIndexAndRenderStateBucket >> 12u;

	U32 indirectIdx;
	InterlockedAdd(g_mdiDrawCounts[renderStateBucket], 1, indirectIdx);
	indirectIdx += g_drawIndirectArgsOffsets[renderStateBucket];

	const GpuSceneRenderable renderableIn = g_renderables[renderableIdx];
	const U32 meshLodOffset = renderableIn.m_geometryOffset + sizeof(GpuSceneMeshLod) * lod;
	const GpuSceneMeshLod meshLod = g_gpuScene.Load<GpuSceneMeshLod>(meshLodOffset);

	DrawIndexedIndirectArgs indirect;
	indirect.m_indexCount = meshLod.m_indexCount;
	indirect.m_instanceCount = 1;
	indirect.m_firstIndex = meshLod.m_firstIndex;
	indirect.m_vertexOffset = 0;
	indirect.m_firstInstance = indirectIdx;
	g_drawIndexedIndirectArgs[indirectIdx] = indirect;

	GpuSceneRenderable renderableOut = renderableIn;
	renderableOut.m_geometryOffset = meshLodOffset;
	g_instanceRateRenderables[indirectIdx] = renderableOut;
}

#pragma anki end
